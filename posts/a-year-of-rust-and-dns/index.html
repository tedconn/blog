<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title></title>
    <link rel="stylesheet" href="https:&#x2F;&#x2F;bluejekyll.github.io&#x2F;blog/css/font-comic-neue.css" />
    <link rel="stylesheet" href="https:&#x2F;&#x2F;bluejekyll.github.io&#x2F;blog/darkmode.css" />
    <link rel="stylesheet" href="https:&#x2F;&#x2F;bluejekyll.github.io&#x2F;blog/lightmode.css" />
    <link rel="stylesheet" href="https:&#x2F;&#x2F;bluejekyll.github.io&#x2F;blog/fontawesome-free-5.15.2-web/css/all.min.css" />
    <link rel="stylesheet" href="https:&#x2F;&#x2F;bluejekyll.github.io&#x2F;blog/fontawesome-free-5.15.2-web/css/brands.min.css" />
    <script src="https:&#x2F;&#x2F;bluejekyll.github.io&#x2F;blog&#x2F;js&#x2F;navbar.js"></script>
    <!-- <script src="https:&#x2F;&#x2F;bluejekyll.github.io&#x2F;blog&#x2F;js&#x2F;navbar.js"
        integrity="sha384-6ea11b2a27dbdb3031babafee75b24601c5d9a7800002d6ab8fd4d9736986d2c73624253573f37723129feb00152985b"></script> -->
</head>

<body class="">
    <nav class="navbar is-spaced" role="navigation" aria-label="main navigation">
        <div class="container is-max-desktop">
            <div class="navbar-brand">
                <a class="navbar-item has-text-weight-bold is-family-monospace" href="https:&#x2F;&#x2F;bluejekyll.github.io&#x2F;blog">
                    let blueJEKYLL=benjaminFRY;
                </a>
                <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false"
                    data-target="navbar-data">
                    <span aria-hidden="true"></span>
                    <span aria-hidden="true"></span>
                    <span aria-hidden="true"></span>
                </a>
            </div>

            <div id="navbar-data" class="navbar-menu">
                <div class="navbar-end">
                    <a class="navbar-item" href="https:&#x2F;&#x2F;bluejekyll.github.io&#x2F;blog/posts">
                        <span class="icon-text">
                            <span class="icon">
                                <i class="fas fa-th-list"></i>
                            </span>
                            <span>Posts</span>
                        </span>
                    </a>
                    <a class="navbar-item" href="https:&#x2F;&#x2F;github.com&#x2F;bluejekyll">
                        <span class="icon-text">
                            <span class="icon">
                                <i class="fab fa-github"></i>
                            </span>
                            <span>Github</span>
                        </span>
                    </a>
                </div>
            </div>
        </div>
    </nav>
    
<section class="hero mb-5">
    <div class="hero-body">
        <div class="container is-max-desktop">
            <p class="title is-2">
                A year of Rust and DNS
            </p>
            <p class="subtitle is-4 is-italic">
                This post is not meant to teach you Rust or DNS. It&#x27;s more of a journal about some things I&#x27;ve found interesting while developing a DNS client and server in Rust
            </p>
            <p class="is-family-monospace is-7 has-text-light">2016-08-21</p>
        </div>
    </div>
</section>

<div class="container is-max-desktop box">
    <article class="content">
        <p><p>Approximately a year and a half ago I discovered possibly the greatest
programming language ever created. It happened while I was learning Go. Go was
a fun language to learn, and coming from Java I appreciated one
particularly awesome thing about it, I could compile a single binary, deploy
and run it quickly and easily. Honestly, I hadn't realized how much I missed
static binaries from C until I wrote a program in Go. There was no classpath, no monkeying with the
default memory settings, no changing the default garbage collector. It was a
nice language, but I had some problems. I missed generics, I missed typed and
checked exceptions, and I couldn't help but feel like I was writing C but with
a Garbage Collector (ok, easier than C and it has memory safety, big bonuses).</p>
<p>Then I started seeing Hacker News talking about this new language called
<a href="https://www.rust-lang.org">Rust</a>. It was marching toward a 1.0 release, I think
it was at 0.8 when I first tried it out. With the help of
<a href="http://rustbyexample.com">Rust by Example</a> I sat down and started learning
the language, every time I wrote something there was an old hardened layer of
programming tarnish that was wiped from my eyes. I had been shown the
light, and there is no going back once you have been to the promised land. All
of my colleagues have gotten tired of me talking about Rust... I definitely
feel like a bible thumper sometimes. But at that point, I still didn't have anything
substantial that I had written in Rust.</p>
<h1 id="then-the-computer-gods-said-rewrite-dns">Then the computer gods said, &quot;rewrite DNS&quot;</h1>
<p><a href="https://www.isc.org/blogs/about-cve-2015-5477-an-error-in-handling-tkey-queries-can-cause-named-to-exit-with-a-require-assertion-failure/">CVE-2015-5477</a> struck BIND9, and it sounded pretty bad. After doing a little research
it became somewhat clear, to me anyway, that BIND's biggest issue is that it is written in C;
buffer overflows, out-of-bound array access, race conditions, etc. Take a look
at the <a href="https://kb.isc.org/category/74/0/10/Software-Products/BIND9/Security-Advisories/">full list</a>
sometime, I think roughly 50% of those could have been avoided by using
(safe) Rust. Is BIND9 the only DNS server out there? No. But it is the most
widely deployed.</p>
<p>Before you call me a C hater, C is still probably my most favorite language.
It's pure, raw power. It's also a huge pain in the neck to debug, and there's
always that question, like what happens when you call <code>strstr()</code> on a non-null
terminated buffer? (yes, that was a fun one to track down, Kevin G.).</p>
<p>So I got started. Here is the first disappointing thing, there is no spec! What
exists are rfc's dating back to 1987, specifically
<a href="https://tools.ietf.org/html/rfc1034">rfc1034</a> and <a href="https://tools.ietf.org/html/rfc1035">rfc1035</a>.
Luckily the IETF marks the status of rfc's (the color coding at the top of the
rfc page), and then it also forward and backward references to rfc's that
update the current rfc or the ones which it obsolete's. My first job was to
organize all of the rfc's that I planned on implementing (this list keeps
changing by-the-way), obviously starting with rfc1035.</p>
<p>So then I got started, on-the-side; and by the way I have two small children
and a full-time job, so
on-the-side for me is not always the easiest time to come up with. Anywhere close
to six hours a week is impressive.</p>
<h1 id="a-dns-client-and-server-is-born">A DNS client and server is born</h1>
<p>From the <a href="https://github.com/bluejekyll/trust-dns/commit/a3496cebf37c5e88bfbd4d7c5f036afe1d61cf6d#diff-04c6e90faac2675aa89e2176d2eec7d8">README.md</a>:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;"># trust-dns
A Rust based DNS server
</span></code></pre>
<p>The commit:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">commit a3496cebf37c5e88bfbd4d7c5f036afe1d61cf6d
Author: Benjamin Fry &lt;benjaminfry@me.com&gt;
Date:   Fri Aug 7 19:47:12 2015 -0700

    Initial commit
</span></code></pre>
<p>It took me a few weeks to <em>mostly</em> complete rfc1035, the basics. The first
thing that I really started appreciating about Rust were the well defined
fixed size integers <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>. It was actually fun to parse
binary streams again! I've been working in Java mainly for the last decade,
I never found bit shifting intuitive in Java because there are only signed
integers. So this was like going back to C. Example DNS header parsing
(current as of this writing):</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">read</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">decoder</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> BinDecoder) -&gt; DecodeResult&lt;</span><span style="color:#b48ead;">Self</span><span style="color:#c0c5ce;">&gt; {
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> id = try!(decoder.</span><span style="color:#96b5b4;">read_u16</span><span style="color:#c0c5ce;">());

  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> q_opcd_a_t_r = try!(decoder.</span><span style="color:#96b5b4;">pop</span><span style="color:#c0c5ce;">());
  </span><span style="color:#65737e;">// if the first bit is set
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> message_type = </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x80 </span><span style="color:#c0c5ce;">&amp; q_opcd_a_t_r) == </span><span style="color:#d08770;">0x80 </span><span style="color:#c0c5ce;">{ MessageType::Response } </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{ MessageType::Query };
  </span><span style="color:#65737e;">// the 4bit opcode, masked and then shifted right 3bits for the u8...
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> op_code: OpCode = ((</span><span style="color:#d08770;">0x78 </span><span style="color:#c0c5ce;">&amp; q_opcd_a_t_r) &gt;&gt; </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">).</span><span style="color:#96b5b4;">into</span><span style="color:#c0c5ce;">();
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> authoritative = (</span><span style="color:#d08770;">0x4 </span><span style="color:#c0c5ce;">&amp; q_opcd_a_t_r) == </span><span style="color:#d08770;">0x4</span><span style="color:#c0c5ce;">;
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> truncation = (</span><span style="color:#d08770;">0x2 </span><span style="color:#c0c5ce;">&amp; q_opcd_a_t_r) == </span><span style="color:#d08770;">0x2</span><span style="color:#c0c5ce;">;
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> recursion_desired = (</span><span style="color:#d08770;">0x1 </span><span style="color:#c0c5ce;">&amp; q_opcd_a_t_r) == </span><span style="color:#d08770;">0x1</span><span style="color:#c0c5ce;">;

  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> r_z_ad_cd_rcod = try!(decoder.</span><span style="color:#96b5b4;">pop</span><span style="color:#c0c5ce;">()); </span><span style="color:#65737e;">// fail fast...
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> recursion_available = (</span><span style="color:#d08770;">0b1000_0000 </span><span style="color:#c0c5ce;">&amp; r_z_ad_cd_rcod) == </span><span style="color:#d08770;">0b1000_0000</span><span style="color:#c0c5ce;">;
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> authentic_data = (</span><span style="color:#d08770;">0b0010_0000 </span><span style="color:#c0c5ce;">&amp; r_z_ad_cd_rcod) == </span><span style="color:#d08770;">0b0010_0000</span><span style="color:#c0c5ce;">;
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> checking_disabled = (</span><span style="color:#d08770;">0b0001_0000 </span><span style="color:#c0c5ce;">&amp; r_z_ad_cd_rcod) == </span><span style="color:#d08770;">0b0001_0000</span><span style="color:#c0c5ce;">;
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> response_code: </span><span style="color:#b48ead;">u8 </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0x0F </span><span style="color:#c0c5ce;">&amp; r_z_ad_cd_rcod;

  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> query_count = try!(decoder.</span><span style="color:#96b5b4;">read_u16</span><span style="color:#c0c5ce;">());
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> answer_count = try!(decoder.</span><span style="color:#96b5b4;">read_u16</span><span style="color:#c0c5ce;">());
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> name_server_count = try!(decoder.</span><span style="color:#96b5b4;">read_u16</span><span style="color:#c0c5ce;">());
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> additional_count = try!(decoder.</span><span style="color:#96b5b4;">read_u16</span><span style="color:#c0c5ce;">());

  Ok(Header { id: id, message_type: message_type, op_code: op_code, authoritative: authoritative,
    truncation: truncation, recursion_desired: recursion_desired,
    recursion_available: recursion_available,
    authentic_data: authentic_data, checking_disabled: checking_disabled,
    response_code: response_code,
    query_count: query_count, answer_count: answer_count,
    name_server_count: name_server_count, additional_count: additional_count })
  }
</span></code></pre>
<p>In each of those operations, I know exactly what is stored at each bit in each
of those variables. I haven't gone back and changed it in some cases yet, but
I've decided to start using this binary int format for checking bits, as I
think it's more clear (as opposed to hex, which you can still see in the above
code block. I need to clean that up, but if it ain't broke don't fix it):</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> recursion_available = (</span><span style="color:#d08770;">0b1000_0000 </span><span style="color:#c0c5ce;">&amp; r_z_ad_cd_rcod) == </span><span style="color:#d08770;">0b1000_0000</span><span style="color:#c0c5ce;">;
</span></code></pre>
<p>If you're unfamiliar with rust, the result of the <code>==</code> operation is a boolean,
so the type of <code>recursion_available</code> is inferred. Also, I know my names look
funny, but each of those characters represents a bit, or more to help me visually
understand the bitfield I'm reading from.</p>
<p>In this bitshift example:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> op_code: OpCode = ((</span><span style="color:#d08770;">0x78 </span><span style="color:#c0c5ce;">&amp; q_opcd_a_t_r) &gt;&gt; </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">).</span><span style="color:#96b5b4;">into</span><span style="color:#c0c5ce;">();
</span></code></pre>
<p>If that operation happened on a 32bit boundary in Java, I'd be scratching my head
(actually a junit test would be easier) trying to remember if I needed <code>&gt;&gt;&gt;</code> or
<code>&gt;&gt;</code>. I know the the answer, do you? In Rust there is no question. I will
be changing that above line to this, because I think it's much clearer:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> op_code: OpCode = ((</span><span style="color:#d08770;">0b0_1111_0_0_0 </span><span style="color:#c0c5ce;">&amp; q_opcd_a_t_r) &gt;&gt; </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">).</span><span style="color:#96b5b4;">into</span><span style="color:#c0c5ce;">();
</span></code></pre>
<p>I have to say, some of the ergonomics of Rust are awesome, like support for the
binary literal, Java just got this in 1.7. And the allowance of the <code>_</code> for
visually separating portions of the literal is awesome, obviously most people
will usually use it as a replacement for <code>,</code> like <code>let million = 1_000_000</code>.
Disecting the above code a little more, that <code>into()</code> is a function from the
<code>From</code> trait <a href="https://github.com/bluejekyll/trust-dns/blob/7b271c468d9c3919d2015a5c75b21fa8503e8b29/src/op/op_code.rs">implementation</a>:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span style="color:#c0c5ce;">From&lt;</span><span style="color:#b48ead;">u8</span><span style="color:#c0c5ce;">&gt; </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">OpCode {
  </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">from</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">u8</span><span style="color:#c0c5ce;">) -&gt; </span><span style="color:#b48ead;">Self </span><span style="color:#c0c5ce;">{
    </span><span style="color:#b48ead;">match</span><span style="color:#c0c5ce;"> value {
      </span><span style="color:#d08770;">0 </span><span style="color:#c0c5ce;">=&gt; OpCode::Query,
      </span><span style="color:#d08770;">2 </span><span style="color:#c0c5ce;">=&gt; OpCode::Status,
      </span><span style="color:#d08770;">4 </span><span style="color:#c0c5ce;">=&gt; OpCode::Notify,
      </span><span style="color:#d08770;">5 </span><span style="color:#c0c5ce;">=&gt; OpCode::Update,
      _ =&gt; panic!(&quot;</span><span style="color:#a3be8c;">unimplemented code: {}</span><span style="color:#c0c5ce;">&quot;, value),
    }
  }
}
</span></code></pre>
<p>The above code shows a basic usage of match on integer and conversion to the
DNS <code>OpCode</code> enum. Notice that <code>panic!</code>, yeah, that's a logic bug.
I just filed the <a href="https://github.com/bluejekyll/trust-dns/issues/36">issue</a>
for it, basically that <code>panic!</code> will crash the server if someone sends a bad
OpCode. This brings up an important point:</p>
<h1 id="rust-does-not-prevent-logic-bugs">Rust does not prevent <em>logic</em> bugs</h1>
<p>Rust prevents memory leaks<a href="https://bluejekyll.github.io/blog/posts/a-year-of-rust-and-dns/?#1">[1]</a>, a subset of concurrency bugs, and others. It's not
some magic bullet, but to not have to deal with memory access issues? Null
pointer dereferences? Memory leaks<a href="https://bluejekyll.github.io/blog/posts/a-year-of-rust-and-dns/?#1">[1]</a>? Yeah, there was a reason I went to Java all
those years ago. But now, I can go back to systems level programming with even
better safety guarantees than Java!</p>
<p>That <code>panic!</code> is residual from when I was still getting comfortable with errors
in Rust. There are some error handling changes coming in Rust
that will make them easier, and <a href="https://crates.io/crates/error-chain">error_chain</a>
is greatly simplifies error type definitions, <a href="https://github.com/bluejekyll/trust-dns/blob/ba8eee06d37e9ad633489ce0595835c5e59fac07/src/error/client_error.rs">example</a>.
I thought I had removed all <code>panic!</code> use cases from areas where they would be
encountered in live code paths, I never claimed to be perfect! (And writing
this post helped uncover a bug, so even if no one reads this, it was worth it).</p>
<h1 id="you-must-deal-with-errors">You must deal with errors</h1>
<p>Rust has made errors something you can not ignore. This is akin to checked
exceptions in Java (by the way, I'm in the camp of all Exceptions should be
checked). Rust uses a similar practice to Java in that, if you don't know how
to deal with an error, just rethrow it (best practice in Java). I'll be converting
that above <code>From</code> to something else soon, but let's look at the simplest form of
error handling:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> query_count = try!(decoder.</span><span style="color:#96b5b4;">read_u16</span><span style="color:#c0c5ce;">());
</span></code></pre>
<p>This reads from the decoder byte stream the next u16. Of course this could fail,
because maybe there isn't enough bytes left to read a u16, or maybe it's a backed
by a <code>TcpStream</code> and the connection fails. But in this context, what can I do
with an error like that? Nothing really, there is no way to recover, so we rethrow.
That's what <code>try!</code> does, but in Rust it's not quite as simple as in Java, Rust
is statically typed. I won't get into error handling in this article, except to
point out a pain point with it, you can learn more about <a href="https://doc.rust-lang.org/book/error-handling.html">error handling here</a>.</p>
<p>Rust has made the wise decision to force you to either propagate errors through
the <code>Result</code> type, or handle them. Because Rust is strongly typed, every function
call which returns an Error will need to compensate for all the inner functions called.</p>
<p>In the above example, we only need to deal with the <code>DecodeError</code> returned from
<code>read_u16()</code>, but in the <code>Client::query()</code> we return <a href="https://github.com/bluejekyll/trust-dns/blob/ba8eee06d37e9ad633489ce0595835c5e59fac07/src/error/client_error.rs">ClientError</a>, which is
is just a union of a bunch of different types:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#c0c5ce;">links {
  </span><span style="color:#b48ead;">super</span><span style="color:#c0c5ce;">::decode_error::Error, </span><span style="color:#b48ead;">super</span><span style="color:#c0c5ce;">::decode_error::ErrorKind, Decode;
  </span><span style="color:#b48ead;">super</span><span style="color:#c0c5ce;">::encode_error::Error, </span><span style="color:#b48ead;">super</span><span style="color:#c0c5ce;">::encode_error::ErrorKind, Encode;
}
</span></code></pre>
<p>While the type itself isn't growing because enums in Rust are more equivalent to
unions in C, the definition is expanding with each additional Error. The <code>Client</code>
ends up with the potential for <code>DecodeError</code> or <code>EncodeError</code> because it's obviously
performing both operations to send and then receive a message. The overhead of
dealing with this was daunting initially, but since better understanding the
problem, it's no longer a significant overhead, and again <code>error_chain</code> has
made it even easier.</p>
<h1 id="implementing-rfc1035-was-deceivingly-easy">Implementing rfc1035 was deceivingly easy</h1>
<p>After a few iterations on the server code and authority, in September of 2015
I had a fully functional DNS server and client. But that's not what I set out
to do. I set out to implement DNSSec, threw in DNSCrypt for fun, and wanted a
dynamic library of which I could be proud.</p>
<p>This brings me to a lull point; DNSSec, how hard could it be? Remember I
mentioned all those rfc's? Well DNSSec has gone through a few revisions, there
is a trail of dead rfc carcasses that can be followed: rfc2065 (1997), obsoleted
by rfc2535 (1999), obsoleted by rfc4033, rfc4034, and rfc4035 (2005), which have some
very important clarifications in rfc6840 (2013). I missed one in there and fixed it
recently, see <a href="https://github.com/bluejekyll/trust-dns/issues/27">issue #27</a>.
Which stems from this brilliant quote:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;"> The guidance in the above paragraph differs from what has been
   published before but is consistent with current common practice.
   Item 3 of Section 6.2 of [RFC4034] says that names in both of these
   RR types should be converted to lowercase.  The earlier [RFC3755]
   says that they should not.  Current practice follows neither document
   fully.
</span></code></pre>
<p>Did you catch that? No one implemented the spec properly, so now the spec is
the implementation. I think that's a tail wagging the dog, right?</p>
<p>Anyway, back to the deceivingly easy bit; perhaps a picture will help:</p>
<p>![Trust-DNS work history]({{ site.url }}{{ site.baseurl }}/assets/trust-dns-work.png)</p>
<p>At <em>blindmans peak</em>, I was riding high. Loving Rust, nothing could stop me. I
had fun adding in support for things like the async io library <code>mio</code>
(I have plans to move to <a href="https://aturon.github.io/blog/2016/08/11/futures/">futures</a>
when I have time). Then I decided it was
time to add DNSSec support. I had to read, and reread, all of the mentioned
rfcs, and some others. I started implementing, and then fell into the <em>pit of
dispair</em> as I tried and tried to get RRSIGs to first parse and then validate
properly. Only to discover that I needed <a href="https://github.com/sfackler/rust-openssl/commit/ef95223d2679d68b36df77393bd334d4da02077f">additional methods</a>
in the Rust OpenSSL port. After learning too much about OpenSSL (oh-my-dear-god I can
not unsee what I saw in there, the C, not Rust).</p>
<p>While in the <em>pit of dispair</em>, I considered many times giving up, with questions like; &quot;What's
the point?&quot;, &quot;There are a ton of DNS servers out there, DJB's is rock solid.
Am I really adding anything new?&quot;, &quot;Is anyone even
going to use this?&quot; I have good answers to all of these, that will eventually
make this implementation unique and offer features that answer long standing
issues that I've had with DNS. So, I slogged through, and made some progress.
Then I discovered that none of my signing logic was working properly. This
brought me to the <em>valley of doom</em>, those questions I was asking myself, they
only got louder and louder. &quot;Stop wasting your time.&quot; But how could I stop? I
made it this far, I must see it through. I needed to go back and reread all the
DNSSec rfc's, and understand what I had screwed up.</p>
<p>Then I climbed <em>saviors peak</em>, which was hard. For any cyclists in the Bay Area,
it's like the Three Bears ride in the East Bay, where the Baby Bear and Mamma Bear hills were
tough, then Papa Bear hill has a false summit, and you still need to go up
the huge last climb to get to the top. The downhill is totally worth it though,
45mph is thrilling on a bike.</p>
<h1 id="tests-as-a-way-of-life">Tests as a way of life</h1>
<p>A feature that I found both surprising, and yet seems so obvious it should be
inherent to all languages, was the embedded tests
with a simple <code>#[test]</code> annotation which causes a test binary to be produced
with the <code>cargo test</code> command. In most languages you usually start by writing
a simple <code>main()</code> with a <code>println!(&quot;hello world&quot;)</code>, in Rust it's even easier to
start with a test. I have &gt; 84% coverage, I can do better, but if you look at the
<a href="https://coveralls.io/github/bluejekyll/trust-dns?branch=master">reports</a>,
the most glaringly uncovered things are actually covered, but in integration
tests, <code>cargo test -- --ignored</code>, which I'm not currently running on Travis.
TCP servers on a free CI service seem like issues will follow. I've never been
a huge fan of aiming too much higher than 85-90% coverage, because I see
diminishing returns beyond that, as Dijkstra said:</p>
<pre style="background-color:#2b303b;">
<code class="language-quote" data-lang="quote"><span style="color:#c0c5ce;"> testing can be a very effective way to show the presence of bugs,
                but it is hopelessly inadequate for showing their absence
</span></code></pre>
<p>My favorite though is the ability to write threaded tests for server code, in Rust it's
made even easier than similar practices I've used in Java:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#c0c5ce;">#[</span><span style="color:#bf616a;">test</span><span style="color:#c0c5ce;">]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">test_server_www_udp</span><span style="color:#c0c5ce;">() {
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> addr = SocketAddr::</span><span style="color:#d08770;">V4</span><span style="color:#c0c5ce;">(SocketAddrV4::new(Ipv4Addr::new(</span><span style="color:#d08770;">127</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">), </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">));
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> udp_socket = UdpSocket::bound(&amp;addr).</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();

  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> ipaddr = udp_socket.</span><span style="color:#96b5b4;">local_addr</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
  println!(&quot;</span><span style="color:#a3be8c;">udp_socket on port: </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, ipaddr);

  thread::Builder::new().</span><span style="color:#96b5b4;">name</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">test_server:udp:server</span><span style="color:#c0c5ce;">&quot;.</span><span style="color:#96b5b4;">to_string</span><span style="color:#c0c5ce;">()).</span><span style="color:#96b5b4;">spawn</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">move </span><span style="color:#c0c5ce;">|| </span><span style="color:#96b5b4;">server_thread_udp</span><span style="color:#c0c5ce;">(udp_socket)).</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();

  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> client_conn = UdpClientConnection::new(ipaddr).</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> client_thread = thread::Builder::new().</span><span style="color:#96b5b4;">name</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">test_server:udp:client</span><span style="color:#c0c5ce;">&quot;.</span><span style="color:#96b5b4;">to_string</span><span style="color:#c0c5ce;">()).</span><span style="color:#96b5b4;">spawn</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">move </span><span style="color:#c0c5ce;">|| </span><span style="color:#96b5b4;">client_thread_www</span><span style="color:#c0c5ce;">(client_conn)).</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();

  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> client_result = client_thread.</span><span style="color:#96b5b4;">join</span><span style="color:#c0c5ce;">();

  assert!(client_result.</span><span style="color:#96b5b4;">is_ok</span><span style="color:#c0c5ce;">(), &quot;</span><span style="color:#a3be8c;">client failed: {:?}</span><span style="color:#c0c5ce;">&quot;, client_result);
}
</span></code></pre>
<p>Teasing this apart, it creates two threads, one for the client, and one for the server.
Both use random local ports, so that we don't have any issues with binding to an
already used socket address. Then we start the server. Next we grab the server's
randomly assigned port, pass that into a new Client and start the client thread.
In tests, I see <code>unwrap()</code> and <code>panic!</code> as perfectly legit. The server thread is dead simple:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">server_thread_udp</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">udp_socket</span><span style="color:#c0c5ce;">: UdpSocket) {
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> catalog = </span><span style="color:#96b5b4;">new_catalog</span><span style="color:#c0c5ce;">();

  </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> server = Server::new(catalog);
  server.</span><span style="color:#96b5b4;">register_socket</span><span style="color:#c0c5ce;">(udp_socket);

  server.</span><span style="color:#96b5b4;">listen</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
}
</span></code></pre>
<p>I started writing tests like this in Java years ago for distributed systems, but
this is much easier than the primitives I had at my disposal in Java. The client
thread is where the meat of the test is:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">client_thread_www</span><span style="color:#c0c5ce;">&lt;C: ClientConnection&gt;(</span><span style="color:#bf616a;">conn</span><span style="color:#c0c5ce;">: C) {
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> name = Name::with_labels(vec![&quot;</span><span style="color:#a3be8c;">www</span><span style="color:#c0c5ce;">&quot;.</span><span style="color:#96b5b4;">to_string</span><span style="color:#c0c5ce;">(), &quot;</span><span style="color:#a3be8c;">example</span><span style="color:#c0c5ce;">&quot;.</span><span style="color:#96b5b4;">to_string</span><span style="color:#c0c5ce;">(), &quot;</span><span style="color:#a3be8c;">com</span><span style="color:#c0c5ce;">&quot;.</span><span style="color:#96b5b4;">to_string</span><span style="color:#c0c5ce;">()]);
  println!(&quot;</span><span style="color:#a3be8c;">about to query server: </span><span style="color:#d08770;">{:?}</span><span style="color:#c0c5ce;">&quot;, conn);
  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> client = Client::new(conn);

  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> response = client.</span><span style="color:#96b5b4;">query</span><span style="color:#c0c5ce;">(&amp;name, DNSClass::</span><span style="color:#d08770;">IN</span><span style="color:#c0c5ce;">, RecordType::A).</span><span style="color:#96b5b4;">expect</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">error querying</span><span style="color:#c0c5ce;">&quot;);

  assert!(response.</span><span style="color:#96b5b4;">get_response_code</span><span style="color:#c0c5ce;">() == ResponseCode::NoError, &quot;</span><span style="color:#a3be8c;">got an error: {:?}</span><span style="color:#c0c5ce;">&quot;, response.</span><span style="color:#96b5b4;">get_response_code</span><span style="color:#c0c5ce;">());

  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> record = &amp;response.</span><span style="color:#96b5b4;">get_answers</span><span style="color:#c0c5ce;">()[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">];
  assert_eq!(record.</span><span style="color:#96b5b4;">get_name</span><span style="color:#c0c5ce;">(), &amp;name);
  assert_eq!(record.</span><span style="color:#96b5b4;">get_rr_type</span><span style="color:#c0c5ce;">(), RecordType::A);
  assert_eq!(record.</span><span style="color:#96b5b4;">get_dns_class</span><span style="color:#c0c5ce;">(), DNSClass::</span><span style="color:#d08770;">IN</span><span style="color:#c0c5ce;">);

  </span><span style="color:#b48ead;">if let </span><span style="color:#c0c5ce;">&amp;RData::A(</span><span style="color:#b48ead;">ref</span><span style="color:#c0c5ce;"> address) = record.</span><span style="color:#96b5b4;">get_rdata</span><span style="color:#c0c5ce;">() {
    assert_eq!(address, &amp;Ipv4Addr::new(</span><span style="color:#d08770;">93</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">184</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">216</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">34</span><span style="color:#c0c5ce;">))
  } </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
    assert!(</span><span style="color:#d08770;">false</span><span style="color:#c0c5ce;">);
  }

  </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> ns: Vec&lt;_&gt; = response.</span><span style="color:#96b5b4;">get_name_servers</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">to_vec</span><span style="color:#c0c5ce;">();
  ns.</span><span style="color:#96b5b4;">sort</span><span style="color:#c0c5ce;">();

  assert_eq!(ns.</span><span style="color:#96b5b4;">len</span><span style="color:#c0c5ce;">(), </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">);
  assert_eq!(ns.</span><span style="color:#96b5b4;">first</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">get_rr_type</span><span style="color:#c0c5ce;">(), RecordType::</span><span style="color:#d08770;">NS</span><span style="color:#c0c5ce;">);
  assert_eq!(ns.</span><span style="color:#96b5b4;">first</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">get_rdata</span><span style="color:#c0c5ce;">(), &amp;RData::</span><span style="color:#d08770;">NS</span><span style="color:#c0c5ce;">(Name::parse(&quot;</span><span style="color:#a3be8c;">a.iana-servers.net.</span><span style="color:#c0c5ce;">&quot;, None).</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">()) );
  assert_eq!(ns.</span><span style="color:#96b5b4;">last</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">get_rr_type</span><span style="color:#c0c5ce;">(), RecordType::</span><span style="color:#d08770;">NS</span><span style="color:#c0c5ce;">);
  assert_eq!(ns.</span><span style="color:#96b5b4;">last</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">get_rdata</span><span style="color:#c0c5ce;">(), &amp;RData::</span><span style="color:#d08770;">NS</span><span style="color:#c0c5ce;">(Name::parse(&quot;</span><span style="color:#a3be8c;">b.iana-servers.net.</span><span style="color:#c0c5ce;">&quot;, None).</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">()) );
}
</span></code></pre>
<p>If you notice, the function is declared as generic over the <code>ClientConnection</code> type,
this allows for a monomorphic function call that works with both TCP and UDP clients,
meaning one test for both TCP and UDP servers and clients. I put the code here for an
example, you can see the rest of the tests in the <a href="https://github.com/bluejekyll/trust-dns/blob/26b44483b0151682a7d835ddbd6ff9261c0651b6/CHANGELOG.md">server.rs</a>
source.</p>
<p>I know that looking at the <code>Name::with_labels()</code> call looks a little clumsy, I want
to clean that up, but haven't quite settled on some ideas around String interning
that I want to play with. In point of fact, my labels implementation in <code>Name</code> is
one of the very few places where I want a garbage collector in Rust, that desire might
go away once I have a better way of performing an intern.</p>
<h1 id="so-where-is-trust-dns-now">So where is Trust-DNS now?</h1>
<p>It's currently not used in production (as far as I know). I've put a lot of work
into validating correctness of what is going on, and have had
<a href="https://github.com/bluejekyll/trust-dns/graphs/contributors">help</a>, more
is always welcome. I want to get a DNS fuzzer running against it to really pound
on it, and then get some benchmark and comparison tests against other servers.</p>
<p>Things I'm proud of: DNSSec support, with client side validation, and zone
signing with local keys. Server and Client both have support for dynamic DNS
with SIG0 validation and auth. Journaling support on the Server with sqlite. EDNS is
supported for greater than 512 byte UDP packets (defaults to 1500).</p>
<p>I'm currently in the middle of working on DNSCrypt<a href="https://bluejekyll.github.io/blog/posts/a-year-of-rust-and-dns/?#2">[2]</a>, and then I'll be moving on
to some more fun ideas. I never imagined it would be this long of a journey,
but it's only just beginning, and along with learning such a spectacular language
it's totally worth it. Thank you to everyone who
spends so much time perfecting Rust and it's ecosystem, you have reinvigorated
my joy of programming.</p>
<p>(I'll try to post more regularly on progress)</p>
<ul>
<li><a name="1">1</a>) I got a lot of feedback on Rust not preventing memory leaks.
For me, in my experience it's at least as good as Java, meaning you have to go
out of your way to cause a situation where a variable will not be dropped. This
can happen in safe code. Examples would be ever growing Vectors, or poor usage
of <code>std::mem::forget</code> which tells Rust not to call drop and cleanup the memory.
When would you want to do this? I've used this when passing objects back to C
through FFI methods, there are other cases. If you want to read a ton, checkout
this post: <a href="https://github.com/rust-lang/rfcs/pull/1066">https://github.com/rust-lang/rfcs/pull/1066</a>.
I left what I wrote mostly so that people could come to it, and then read this,
think about it, and then realize no language actually prevents memory leaks, but
Rust is memory safe...</li>
<li><a name="2">2</a>) After some offline discussion and this issue:
Feature request: &quot;RFC 7858, DNS over TLS <a href="https://github.com/bluejekyll/trust-dns/issues/38">#38</a>&quot;,
I'm very much thinking of shelving my work on DNSCrypt and focusing instead on
DNS over TLS</li>
</ul>
</p>
    </article>
    <section class="section">
        <div>
            <a href="https://twitter.com/intent/tweet?text=A year of Rust and DNS&url=https:&#x2F;&#x2F;bluejekyll.github.io&#x2F;blog&#x2F;posts&#x2F;a-year-of-rust-and-dns&#x2F;&via=https:&#x2F;&#x2F;twitter.com&#x2F;benj_fry&related=https:&#x2F;&#x2F;twitter.com&#x2F;benj_fry"
                rel="nofollow" target="_blank" title="Share on Twitter">
                <span class="icon-text button">
                    <span class="icon">
                        <i class="fab fa-twitter-square"></i>
                    </span>
                    <span>Tweet this</span>
                </span>
            </a>
            <a href="http://www.reddit.com/submit?url=https:&#x2F;&#x2F;bluejekyll.github.io&#x2F;blog&#x2F;posts&#x2F;a-year-of-rust-and-dns&#x2F;&title=A year of Rust and DNS" rel="nofollow"
                target="_blank" title="Discuss on Reddit">
                <span class="icon-text button">
                    <span class="icon">
                        <i class="fab fa-reddit-square"></i>
                    </span>
                    <span>Talk on Reddit</span>
                </span>
            </a>
            <a href="javascript:window.location=%22http://news.ycombinator.com/submitlink?u=%22+encodeURIComponent(document.location)+%22&t=%22+encodeURIComponent(document.title)"
                title="Discuss on Hacker News">
                <span class="icon-text button">
                    <span class="icon">
                        <i class="fab fa-hacker-news-square"></i>
                    </span>
                    <span>Discuss on Hacker News</span>
                </span>
            </a>
        </div>
    </section>
</div>


    <footer class="footer">
        <div class="container is-max-desktop">
            <div class="content  has-text-centered">
                <p class="is-size-7 has-text-dark">A Self-proclaimed Rust evangelist, Java distributed systems engineer, recovering C&#x2F;C++ masochist; Pie and bread maker; Cyclist; Raiser of Humans.</p>
                <h4 class="3sidebar-title text-center">Contact</h4>
                <div>
                    <a class="" href="mailto:benjaminfry@me.com">
                        <span class="icon-text">
                            <span class="icon">
                                <i class="fas fa-paper-plane"></i>
                            </span>
                            <span>benjaminfry@me.com</span>
                        </span>
                    </a>
                </div>
                <div>
                    <a class="" href="https:&#x2F;&#x2F;github.com&#x2F;bluejekyll">
                        <span class="icon-text">
                            <span class="icon">
                                <i class="fab fa-github"></i>
                            </span>
                            <span>Github</span>
                        </span>
                    </a>
                </div>
                <div>
                    <a class="" href="https:&#x2F;&#x2F;twitter.com&#x2F;benj_fry">
                        <span class="icon-text">
                            <span class="icon">
                                <i class="fab fa-twitter"></i>
                            </span>
                            <span>Twitter</span>
                        </span>
                    </a>
                </div>
                <div>
                    <a class="" href="https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;benjamin-fry-8b83072&#x2F;">
                        <span class="icon-text">
                            <span class="icon">
                                <i class="fab fa-linkedin"></i>
                            </span>
                            <span>LinkedIn</span>
                        </span>
                    </a>
                </div>
            </div>
        </div>
        </div>
    </footer>
</body>

</html>